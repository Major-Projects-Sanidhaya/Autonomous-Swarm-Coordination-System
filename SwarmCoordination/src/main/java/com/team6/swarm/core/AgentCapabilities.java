/**
 * AGENTCAPABILITIES CLASS - Agent Performance and Capability Reporting (Week 5-6)
 *
 * PURPOSE:
 * - Reports detailed information about what each agent can currently do
 * - Enables Lauren's intelligence system to make smart task assignments
 * - Tracks agent performance metrics and operational limitations
 * - Provides real-time capability assessment for decision-making
 *
 * DESIGN PATTERNS USED:
 * 1. Data Transfer Object (DTO) - Encapsulates agent capability data
 * 2. Builder Pattern - Fluent API for capability updates
 * 3. Immutable Snapshot - Thread-safe capability reporting
 *
 * CORE METRICS:
 * 1. movementCapability - Current movement effectiveness (0.0-1.0)
 * 2. communicationCapability - Radio effectiveness (0.0-1.0)
 * 3. batteryCapacity - Current battery level (0.0-1.0)
 * 4. processingCapacity - CPU availability (0.0-1.0)
 * 5. taskLoadFactor - How busy the agent is (0.0-1.0)
 * 6. reliabilityScore - Historical success rate (0.0-1.0)
 *
 * CAPABILITY CALCULATIONS:
 * - movementCapability = batteryLevel * (1.0 - taskLoad) * reliabilityFactor
 * - communicationCapability = signalStrength * batteryLevel
 * - taskLoadFactor = activeTaskCount / maxConcurrentTasks
 * - reliabilityScore = successfulTasks / totalTasks (rolling average)
 *
 * USAGE PATTERNS:
 * 1. Query for task assignment:
 *    if (capabilities.canPerformTask(TaskType.SCOUT)) { assign(task); }
 *
 * 2. Performance monitoring:
 *    if (capabilities.getOverallCapability() < 0.3) { reassignTasks(); }
 *
 * 3. Health check:
 *    if (capabilities.isDegraded()) { sendToMaintenance(); }
 *
 * INTEGRATION POINTS:
 * - Generated by: Agent (periodic self-assessment)
 * - Consumed by: Lauren's TaskAllocator for assignment decisions
 * - Monitored by: SystemController for health tracking
 * - Visualized by: Anthony's UI for operator awareness
 *
 * THRESHOLDS:
 * - CRITICAL: capability < 0.2 (agent needs immediate attention)
 * - DEGRADED: capability < 0.5 (reduced effectiveness)
 * - OPTIMAL: capability >= 0.8 (full performance)
 */
package com.team6.swarm.core;

import java.util.HashMap;
import java.util.Map;

public class AgentCapabilities {
    // Agent identification
    public final int agentId;
    public final long timestamp;

    // Core capability metrics (0.0 = disabled, 1.0 = full capacity)
    private double movementCapability;
    private double communicationCapability;
    private double batteryCapacity;
    private double processingCapacity;
    private double taskLoadFactor;
    private double reliabilityScore;

    // Performance tracking
    private int totalTasksAttempted;
    private int successfulTasks;
    private int failedTasks;
    private long lastTaskCompletionTime;

    // Operational constraints
    private double maxSpeed;
    private double currentSpeed;
    private double communicationRange;
    private boolean isFunctional;

    // Task-specific capabilities
    private Map<String, Boolean> taskCapabilities;

    // Capability thresholds
    public static final double CRITICAL_THRESHOLD = 0.2;
    public static final double DEGRADED_THRESHOLD = 0.5;
    public static final double OPTIMAL_THRESHOLD = 0.8;

    /**
     * Constructor - Create capability snapshot for agent
     */
    public AgentCapabilities(int agentId, AgentState state) {
        this.agentId = agentId;
        this.timestamp = System.currentTimeMillis();
        this.taskCapabilities = new HashMap<>();

        // Initialize from agent state
        updateFromState(state);
    }

    /**
     * Update capabilities based on current agent state
     */
    public void updateFromState(AgentState state) {
        // Battery capacity directly from state
        this.batteryCapacity = state.batteryLevel;

        // Movement capability based on battery and status
        this.maxSpeed = state.maxSpeed;
        this.currentSpeed = state.velocity.magnitude();
        this.movementCapability = calculateMovementCapability(state);

        // Communication capability based on battery and range
        this.communicationRange = state.communicationRange;
        this.communicationCapability = calculateCommunicationCapability(state);

        // Processing capacity based on status
        this.processingCapacity = calculateProcessingCapacity(state);

        // Overall functionality
        this.isFunctional = state.status == AgentStatus.ACTIVE ||
                           state.status == AgentStatus.BATTERY_LOW;

        // Update reliability score
        updateReliabilityScore();
    }

    /**
     * Calculate movement capability (0.0-1.0)
     */
    private double calculateMovementCapability(AgentState state) {
        if (state.status == AgentStatus.FAILED || state.status == AgentStatus.INACTIVE) {
            return 0.0;
        }

        // Base capability on battery and load
        double batteryFactor = state.batteryLevel;
        double loadFactor = 1.0 - taskLoadFactor;
        double statusFactor = state.status == AgentStatus.ACTIVE ? 1.0 : 0.5;

        return batteryFactor * loadFactor * statusFactor * reliabilityScore;
    }

    /**
     * Calculate communication capability (0.0-1.0)
     */
    private double calculateCommunicationCapability(AgentState state) {
        if (state.status == AgentStatus.FAILED) {
            return 0.0;
        }

        // Communication depends on battery and signal strength
        double batteryFactor = state.batteryLevel;
        double signalFactor = 1.0; // Assume full signal for now
        double statusFactor = state.status == AgentStatus.ACTIVE ? 1.0 : 0.7;

        return batteryFactor * signalFactor * statusFactor;
    }

    /**
     * Calculate processing capacity (0.0-1.0)
     */
    private double calculateProcessingCapacity(AgentState state) {
        if (state.status == AgentStatus.FAILED || state.status == AgentStatus.MAINTENANCE) {
            return 0.0;
        }

        // Processing capacity inversely related to task load
        return 1.0 - (taskLoadFactor * 0.8); // 20% always available
    }

    /**
     * Update reliability score based on task history
     */
    private void updateReliabilityScore() {
        if (totalTasksAttempted == 0) {
            this.reliabilityScore = 1.0; // New agents start with full trust
        } else {
            // Rolling average with bias toward recent performance
            double successRate = (double) successfulTasks / totalTasksAttempted;

            // Weight recent performance higher (exponential moving average)
            this.reliabilityScore = 0.7 * this.reliabilityScore + 0.3 * successRate;

            // Clamp to valid range
            this.reliabilityScore = Math.max(0.0, Math.min(1.0, this.reliabilityScore));
        }
    }

    /**
     * Record task completion (for reliability tracking)
     */
    public void recordTaskCompletion(boolean success) {
        totalTasksAttempted++;
        if (success) {
            successfulTasks++;
        } else {
            failedTasks++;
        }
        lastTaskCompletionTime = System.currentTimeMillis();
        updateReliabilityScore();
    }

    /**
     * Update task load factor
     */
    public void setTaskLoadFactor(double loadFactor) {
        this.taskLoadFactor = Math.max(0.0, Math.min(1.0, loadFactor));
    }

    /**
     * Check if agent can perform specific task type
     */
    public boolean canPerformTask(String taskType) {
        // Check if functional
        if (!isFunctional) {
            return false;
        }

        // Check minimum capability threshold
        if (getOverallCapability() < CRITICAL_THRESHOLD) {
            return false;
        }

        // Check task-specific requirements
        Boolean taskCapable = taskCapabilities.get(taskType);
        if (taskCapable != null && !taskCapable) {
            return false;
        }

        return true;
    }

    /**
     * Calculate overall capability score (0.0-1.0)
     * Weighted average of all capability metrics
     */
    public double getOverallCapability() {
        if (!isFunctional) {
            return 0.0;
        }

        // Weighted average (movement most important for swarm)
        double weights[] = {0.3, 0.2, 0.25, 0.15, 0.1};
        double capabilities[] = {
            movementCapability,
            communicationCapability,
            batteryCapacity,
            processingCapacity,
            reliabilityScore
        };

        double weightedSum = 0.0;
        for (int i = 0; i < weights.length; i++) {
            weightedSum += weights[i] * capabilities[i];
        }

        return weightedSum;
    }

    /**
     * Check if agent is in critical state
     */
    public boolean isCritical() {
        return getOverallCapability() < CRITICAL_THRESHOLD || batteryCapacity < 0.1;
    }

    /**
     * Check if agent is degraded
     */
    public boolean isDegraded() {
        return getOverallCapability() < DEGRADED_THRESHOLD;
    }

    /**
     * Check if agent is operating optimally
     */
    public boolean isOptimal() {
        return getOverallCapability() >= OPTIMAL_THRESHOLD;
    }

    /**
     * Get capability status as string
     */
    public String getCapabilityStatus() {
        if (isCritical()) return "CRITICAL";
        if (isDegraded()) return "DEGRADED";
        if (isOptimal()) return "OPTIMAL";
        return "NORMAL";
    }

    /**
     * Enable/disable specific task capability
     */
    public void setTaskCapability(String taskType, boolean capable) {
        taskCapabilities.put(taskType, capable);
    }

    /**
     * Get detailed capability report
     */
    public String getDetailedReport() {
        StringBuilder report = new StringBuilder();
        report.append(String.format("Agent %d Capabilities [%s]\n", agentId, getCapabilityStatus()));
        report.append(String.format("  Overall: %.2f%%\n", getOverallCapability() * 100));
        report.append(String.format("  Movement: %.2f%% (%.1f/%.1f speed)\n",
            movementCapability * 100, currentSpeed, maxSpeed));
        report.append(String.format("  Communication: %.2f%% (range: %.1f)\n",
            communicationCapability * 100, communicationRange));
        report.append(String.format("  Battery: %.2f%%\n", batteryCapacity * 100));
        report.append(String.format("  Processing: %.2f%%\n", processingCapacity * 100));
        report.append(String.format("  Task Load: %.2f%%\n", taskLoadFactor * 100));
        report.append(String.format("  Reliability: %.2f%% (%d/%d tasks)\n",
            reliabilityScore * 100, successfulTasks, totalTasksAttempted));
        return report.toString();
    }

    // Getters
    public double getMovementCapability() { return movementCapability; }
    public double getCommunicationCapability() { return communicationCapability; }
    public double getBatteryCapacity() { return batteryCapacity; }
    public double getProcessingCapacity() { return processingCapacity; }
    public double getTaskLoadFactor() { return taskLoadFactor; }
    public double getReliabilityScore() { return reliabilityScore; }
    public int getTotalTasksAttempted() { return totalTasksAttempted; }
    public int getSuccessfulTasks() { return successfulTasks; }
    public int getFailedTasks() { return failedTasks; }
    public boolean isFunctional() { return isFunctional; }

    @Override
    public String toString() {
        return String.format("AgentCapabilities[Agent %d: %s, Overall=%.2f, Battery=%.2f, Reliability=%.2f]",
            agentId, getCapabilityStatus(), getOverallCapability(), batteryCapacity, reliabilityScore);
    }
}
